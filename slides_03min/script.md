# OptimalApplication.jl

Hello, my name is Max Kapur, and today I will be talking about OptimalApplication.jl, which is a Julia package that I have been developing as part of my research as a graduate student in the department of industrial engineering here at Seoul National University. 

My research concerns a combinatorial optimization problem called the "college application problem," which can be summarized as follows. We are a student trying to decide where to apply to college. For each school, we know how much utility we get from going there, and the probability that we will be admitted if we apply. Each school has an application fee, and we have a limited budget to spend on applications. Our goal is to determine the "application portfolio," or set of schools to apply to, that maximizes the expected utility of the school that we ultimately attend—that is, the *best* school that we get into. So, we are dealing with a "maximax"-type objective function over a knapsack constraint, and this fact renders the problem difficult to solve in polynomial time. In my thesis, I discuss a variety of exact, approximate, and heuristic algorithms for this problem, and the OptimalApplication.jl Julia package implements them.

The algorithms are summarized on this slide. Briefly, there is a special case that can be solved in polynomial time, and I offer a couple of implementations of this algorithm that use a different internal data structure. For the general problem, the most effective algorithms are dynamic programs: `optimalportfolio_dynamicprogram` gives an exact solution, and `optimalportfolio_fptas` computes a solution that is within $\varepsilon$ of optimality, where $\varepsilon$ is chosen by the user. There is also a branch-and-bound algorithm, which is primarily of theoretical interest, and a simulated annealing algorithm which is very efficient but has no accuracy guarantee.

Why Julia? Multiple dispatch and the ability to create structs with parametric type fields makes it easy to write code that can accept a variety of user input—for example, users can input their utility as a float or an integer and the algorithms remain type-stable. Next, Julia's convenient macros like `@threads` made it easy to parallelize our computational experiment at a high level, increasing the number of samples we could use in the performance benchmark. Finally, the packaging toolkit makes it very easy to generate code that is portable to other Julia users, and the open package ecosystem has been a very helpful opportunity to get feedback from more experienced Julia developers.

Going forward, there is room to make the code in OptimalApplication.jl much more generic. I recently learned about a package called Bonobo.jl, which provides an abstract interface for a variety of branch-and-bound algorithms. By implementing our linear relaxation in Bonobo.jl, we can extend the college application problem to more complex constraint structures.

Here is my contact information. I'd be eager to get some feedback on this package, the quality of my code, and possibilities for improving or extending its functionality. 
